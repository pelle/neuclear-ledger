package org.neuclear.ledger.tests;

import junit.framework.TestCase;
import org.neuclear.commons.crypto.CryptoTools;
import org.neuclear.ledger.*;

import java.util.Date;

/**
 * (C) 2003 Antilles Software Ventures SA
 * User: pelleb
 * Date: Jan 22, 2003
 * Time: 4:18:35 PM
 * $Id: AbstractLedgerTest.java,v 1.12 2004/04/27 15:23:54 pelle Exp $
 * $Log: AbstractLedgerTest.java,v $
 * Revision 1.12  2004/04/27 15:23:54  pelle
 * Due to a new API change in 0.5 I have changed the name of Ledger and it's implementers to LedgerController.
 *
 * Revision 1.11  2004/04/23 19:09:16  pelle
 * Lots of cleanups and improvements to the userinterface and look of the bux application.
 * <p/>
 * Revision 1.10  2004/04/19 18:57:27  pelle
 * Updated Ledger to support more advanced book information.
 * You can now create a book or fetch a book by doing getBook(String id) on the ledger.
 * You can register a book or upddate an existing one using registerBook()
 * SimpleLedger now works and passes all tests.
 * HibernateLedger has been implemented, but there are a few things that dont work yet.
 * <p/>
 * Revision 1.9  2004/04/12 19:26:37  pelle
 * Hibernate and Pervayler implementations of the Ledger all pass now for both currency and ledger tests.
 * <p/>
 * Revision 1.8  2004/04/06 22:50:14  pelle
 * Updated Unit Tests
 * <p/>
 * Revision 1.7  2004/04/05 22:06:46  pelle
 * added setHeldReceiptId() method to ledger
 * <p/>
 * Revision 1.6  2004/03/31 23:11:09  pelle
 * Reworked the ID's of the transactions. The primary ID is now the request ID.
 * Receipt ID's are optional and added using a separate set method.
 * The various interactive passphrase agents now have shell methods for the new interactive approach.
 * <p/>
 * Revision 1.5  2004/03/25 21:39:43  pelle
 * Modified expire tests a bit to eliminate one cause for an error
 * <p/>
 * Revision 1.4  2004/03/25 19:03:23  pelle
 * PostedTransaction and friend now verify the unpostedtransaction is balanced.
 * Updated schema for HHeld to include a cancelled field and a completed field. (The latter doesnt yet work right). Need to read more Hibernate docs to find out why.
 * <p/>
 * Revision 1.3  2004/03/25 16:44:21  pelle
 * Added getTestBalance() and isBalanced() to Ledger to see if ledger is balanced.
 * The hibernate implementation has changed the comment size to 255 to work with mysql and now
 * has included hibernates full hibernate.properties to make it easier to try various databases.
 * It has now been tested with hsql and mysql.
 * <p/>
 * Revision 1.2  2004/03/24 23:12:34  pelle
 * Working on Hibernate Implementation.
 * <p/>
 * Revision 1.1  2004/03/22 23:20:51  pelle
 * Working on Hibernate Implementation.
 * <p/>
 * Revision 1.2  2004/03/22 21:59:38  pelle
 * SimpleLedger now passes all unit tests
 * <p/>
 * Revision 1.1  2004/03/22 20:08:24  pelle
 * Added simple ledger for unit testing and in memory use
 * <p/>
 * Revision 1.12  2004/03/22 17:33:02  pelle
 * Added a verified transfer to neuclear-ledger.
 * Added InsufficientFundsException to be thrown if transfer isnt verified.
 * HeldTransfers also are now verified.
 * <p/>
 * Revision 1.11  2004/03/21 00:48:36  pelle
 * The problem with Enveloped signatures has now been fixed. It was a problem in the way transforms work. I have bandaided it, but in the future if better support for transforms need to be made, we need to rethink it a bit. Perhaps using the new crypto channel's in neuclear-commons.
 * <p/>
 * Revision 1.10  2004/01/02 23:18:35  pelle
 * Added StatementFactory pattern and refactored the ledger to use it.
 * <p/>
 * Revision 1.9  2003/12/31 00:39:05  pelle
 * Added Drivers for handling different Database dialects in the entity model.
 * Added BookBrowser pattern to ledger, simplifying the statement writing process.
 * <p/>
 * Revision 1.8  2003/12/26 22:50:52  pelle
 * Mainly fixes to SQLLedger to support the schema generated by the new EntityModel
 * <p/>
 * Revision 1.7  2003/12/24 00:24:33  pelle
 * Created a kind of poor man's version of ofbiz.org's EntityEngine. It doesnt use xml to configure it, but code.
 * Should mainly be used to create tables. Can also insert rows, but hasnt been thoroughly tested.
 * At some point I will improve that part and add some kind of smart querying engine to it. Similar to EntityEngine. But I dont
 * need that myself right now.
 * SQLLedger now uses this to create its tables. It is not fully working yet, but will be shortly.
 * <p/>
 * Revision 1.6  2003/12/03 23:21:43  pelle
 * Got rid of ofbiz support. Way over the top for our use.
 * <p/>
 * Revision 1.5  2003/11/21 04:43:21  pelle
 * EncryptedFileStore now works. It uses the PBECipher with DES3 afair.
 * Otherwise You will Finaliate.
 * Anything that can be final has been made final throughout everyting. We've used IDEA's Inspector tool to find all instance of variables that could be final.
 * This should hopefully make everything more stable (and secure).
 * <p/>
 * Revision 1.4  2003/11/11 21:17:32  pelle
 * Further vital reshuffling.
 * org.neudist.crypto.* and org.neudist.utils.* have been moved to respective areas under org.neuclear.commons
 * org.neuclear.signers.* as well as org.neuclear.passphraseagents have been moved under org.neuclear.commons.crypto as well.
 * Did a bit of work on the Canonicalizer and changed a few other minor bits.
 * <p/>
 * Revision 1.3  2003/10/29 21:15:13  pelle
 * Refactored the whole signing process. Now we have an interface called Signer which is the old SignerStore.
 * To use it you pass a byte array and an alias. The sign method then returns the signature.
 * If a Signer needs a passphrase it uses a PassPhraseAgent to present a dialogue box, read it from a command line etc.
 * This new Signer pattern allows us to use secure signing hardware such as N-Cipher in the future for server applications as well
 * as SmartCards for end user applications.
 * <p/>
 * Revision 1.2  2003/10/28 23:43:15  pelle
 * The GuiDialogAgent now works. It simply presents itself as a simple modal dialog box asking for a passphrase.
 * The two Signer implementations both use it for the passphrase.
 * <p/>
 * Revision 1.1.1.1  2003/09/20 23:16:21  pelle
 * First revision of neuclear-ledger in /cvsroot/neuclear
 * Older versions can be found /cvsroot/neuclear
 * <p/>
 * Revision 1.15  2003/08/08 23:05:12  pelle
 * Updated to use PicoContainer.
 * This will be made more elegant as we go along.
 * <p/>
 * Revision 1.14  2003/08/06 19:16:32  pelle
 * Updated various missing items.
 * <p/>
 * Revision 1.13  2003/08/06 16:41:22  pelle
 * Fixed a few implementation bugs with regards to the Held Transactions
 * <p/>
 * Revision 1.12  2003/08/01 21:59:47  pelle
 * More changes to the way helds are managed.
 * <p/>
 * Revision 1.11  2003/07/30 16:27:55  pelle
 * Final fixes for unit tests.
 * Renamed implementHeld() => complete()
 * Had to override reverse() to make complete work.
 * Note: had to "fix" a unit test to make SimpleLedger pass
 * I dont have time to fix it at the moment. I suspect its simple.
 * <p/>
 * Revision 1.10  2003/07/29 22:57:50  pelle
 * New version with refactored support for HeldTransactions.
 * Please note that this causes a sql exception when adding held_item rows.
 * <p/>
 * Revision 1.9  2003/07/28 21:29:15  pelle
 * Changed a few things in the LedgerFactory.
 * Still not quite there yet.
 * <p/>
 * Revision 1.8  2003/07/23 17:19:26  pelle
 * Ledgers now have a required display name.
 * <p/>
 * Revision 1.7  2003/07/21 19:43:39  pelle
 * Moved the Revisioning tests into the main AbstractLedgerTest.
 * Fixed the getTransactionTime method in SQLLedger.
 * <p/>
 * Revision 1.6  2003/07/21 18:35:15  pelle
 * Completed Exception handling refactoring
 * <p/>
 * Revision 1.5  2003/07/21 17:47:37  pelle
 * Held transactions now work in SQL
 * <p/>
 * Revision 1.4  2003/07/18 20:27:39  pelle
 * *** empty log message ***
 * <p/>
 * Revision 1.3  2003/07/17 22:33:57  pelle
 * Fixed various problems. Lets see how we do. I waiting for the autoincrement to work on the entries.
 * <p/>
 * Revision 1.2  2003/07/16 18:08:49  pelle
 * Adding the first parts of sql support.
 * <p/>
 * Revision 1.1  2003/01/25 19:14:47  pelle
 * The ridiculously simple SimpleLedger now passes initial test.
 * I've split the Transaction Class into two sub classes and made Transaction  abstract.
 * The two new Transaction Classes reflect the state of the Transaction and their methods reflect this.
 */
public abstract class AbstractLedgerTest extends TestCase {
    static final String BOB = "bob";
    static final String ALICE = "alice";
    static final String CAROL = "carol";


    public AbstractLedgerTest(final String s) {
        super(s);
    }

    /**
     * Sets up the fixture, for example, open a network connection.
     * This method is called before a test is executed.
     */
    protected void setUp() throws Exception {
        ledger = createLedger();
    }

    /**
     * Tears down the fixture, for example, close a network connection.
     * This method is called after a test is executed.
     */
    protected void tearDown() throws Exception {
        ledger.close();
    }

    public abstract LedgerController createLedger() throws LowlevelLedgerException, UnknownLedgerException;

    private final PostedTransaction transfer(final String from, final String to, final double amount, final String comment) throws InvalidTransactionException, LowlevelLedgerException, UnknownBookException {
        PostedTransaction tran = ledger.transfer(CryptoTools.createRandomID(), from, to, amount, comment);
        try {
            ledger.setReceiptId(tran.getRequestId(), CryptoTools.createRandomID());
        } catch (UnknownTransactionException e) {
            assertTrue(false);
        }
        return tran;

    }

    public final PostedHeldTransaction hold(final String from, final String to, final Date expires, final double amount, final String comment) throws InvalidTransactionException, UnBalancedTransactionException, LowlevelLedgerException, UnknownBookException {
        PostedHeldTransaction tran = ledger.hold(CryptoTools.createRandomID(), from, to, expires, amount, comment);
        try {
            ledger.setHeldReceiptId(tran.getRequestId(), CryptoTools.createRandomID());
        } catch (UnknownTransactionException e) {
            assertTrue(false);
        }
        return tran;
    }

    public final void testTransfer() throws LedgerException {
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);
        final double amount = 100;

        transfer(ALICE, BOB, amount, "LOAN");
        assertEquals("ALICE BALANCE", aliceBalance - amount, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE", bobBalance + amount, ledger.getBalance(BOB), 0);

        transfer(BOB, ALICE, amount, "Repayment");
        assertEquals("REPAY ALICE BALANCE", aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals("REPAY BOB BALANCE", bobBalance, ledger.getBalance(BOB), 0);
        transfer(BOB, ALICE, 5, "Interest");
        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));

        assertTrue("Ledger is balanced", ledger.isBalanced());
    }

    public final void testVerifiedTransfer() throws LedgerException {
        // Need a positive amount in alice's account
        if (ledger.getAvailableBalance(ALICE) < 100)
            transfer("MONEY PRESS", ALICE, -ledger.getAvailableBalance(ALICE) + 100, "FUND");
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);
        final double amount = 100;

        assertTrue("ALICE has a balance of 100 or more", aliceBalance >= 100);

        ledger.verifiedTransfer(ALICE, BOB, amount, "LOAN");
        assertEquals("ALICE BALANCE", aliceBalance - amount, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE", bobBalance + amount, ledger.getBalance(BOB), 0);

        // Now check that it throws InsufficientFundsException
        try {
            ledger.verifiedTransfer(ALICE, BOB, ledger.getAvailableBalance(ALICE) + 10, "To much");
            assertTrue("InssuficientFundsException should have been thrown. Attempted to transfer: " + (ledger.getAvailableBalance(ALICE) + 10), false);
        } catch (InsufficientFundsException e) {
            ;
        }


        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
        assertTrue("Ledger is balanced", ledger.isBalanced());
    }

    public final void testMultiTransfer() throws UnBalancedTransactionException, LowlevelLedgerException, InvalidTransactionException, UnknownTransactionException, UnknownBookException {
        final double bobBalance = ledger.getBalance(CAROL);
        int cumulative = 0;
        for (int i = 0; i < 100; i++) {
            transfer("Issuer", CAROL, i, "fund it");
            cumulative += i;
            assertEquals("BOB BALANCE", bobBalance + cumulative, ledger.getBalance(CAROL), 0);
            assertEquals("BOB AVAILABLE BALANCE", ledger.getBalance(CAROL), ledger.getAvailableBalance(CAROL), 0);
        }
        System.out.println("Bob's Balance: " + ledger.getBalance(CAROL));
        assertTrue("Ledger is balanced", ledger.isBalanced());
    }

    public final void testBalance() throws LedgerException {
        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
        assertTrue("Ledger is balanced", ledger.isBalanced());
    }

    public final void testHoldAndExpireTransfer() throws LowlevelLedgerException, UnBalancedTransactionException, InvalidTransactionException, UnknownBookException {
        ensureBalance(100.0);
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);
        final double amount = 100;
        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));

        hold(ALICE, BOB, new Date(System.currentTimeMillis() + 5000), amount, "LOAN");
        assertEquals("ALICE Available BALANCE", aliceBalance - amount, ledger.getAvailableBalance(ALICE), 0);
        assertEquals("BOB Available BALANCE", bobBalance, ledger.getAvailableBalance(BOB), 0);
        assertEquals("ALICE BALANCE", aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE", bobBalance, ledger.getBalance(BOB), 0);

        try {
            Thread.currentThread().sleep(5000);
        } catch (InterruptedException e) {
            ;
        }
        assertEquals("ALICE BALANCE EXPIRED", aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE EXPIRED", bobBalance, ledger.getBalance(BOB), 0);

        assertEquals("ALICE Available BALANCE EXPIRED", aliceBalance, ledger.getAvailableBalance(ALICE), 0);
        assertEquals("BOB Available BALANCE EXPIRED", bobBalance, ledger.getAvailableBalance(BOB), 0);


        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
        assertTrue("Ledger is balanced", ledger.isBalanced());
    }

    private void ensureBalance(final double target) throws LowlevelLedgerException, InvalidTransactionException, UnknownBookException {
        if (ledger.getAvailableBalance(ALICE) < target)
            transfer("MONEY PRESS", ALICE, -ledger.getAvailableBalance(ALICE) + target, "FUND");
    }

    public final void testHoldAndCancelTransfer() throws LowlevelLedgerException, UnBalancedTransactionException, InvalidTransactionException, UnknownTransactionException, UnknownBookException {
        if (ledger.getAvailableBalance(ALICE) < 100)
            transfer("MONEY PRESS", ALICE, -ledger.getAvailableBalance(ALICE) + 100, "FUND");
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);
        final double amount = 100;
        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));

        PostedHeldTransaction tran = hold(ALICE, BOB, new Date(System.currentTimeMillis() + 5000), amount, "LOAN");
        assertEquals("ALICE BALANCE", aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE", bobBalance, ledger.getBalance(BOB), 0);

        assertEquals("ALICE Available BALANCE", aliceBalance - amount, ledger.getAvailableBalance(ALICE), 0);
        assertEquals("BOB Available BALANCE", bobBalance, ledger.getAvailableBalance(BOB), 0);

        final Date before = new Date();
        final Date date = ledger.performCancelHold(tran);
        assertNotNull(date);
        assertTrue(!date.before(before));
        assertEquals("ALICE BALANCE CANCELLED", aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE CANCELLED", bobBalance, ledger.getBalance(BOB), 0);

        assertEquals("ALICE Available BALANCE CANCELLED", aliceBalance, ledger.getAvailableBalance(ALICE), 0);
        assertEquals("BOB Available BALANCE CANCELLED", bobBalance, ledger.getAvailableBalance(BOB), 0);


        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
        assertTrue("Ledger is balanced", ledger.isBalanced());
    }

    public final void testHoldAndCompleteTransfer() throws LowlevelLedgerException, UnBalancedTransactionException, InvalidTransactionException, UnknownTransactionException, TransactionExpiredException, UnknownBookException {
        if (ledger.getAvailableBalance(ALICE) < 100)
            transfer("MONEY PRESS", ALICE, -ledger.getAvailableBalance(ALICE) + 100, "FUND");
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);
        final double amount = 100;
        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));

        PostedHeldTransaction tran = hold(ALICE, BOB, new Date(System.currentTimeMillis() + 5000), amount, "LOAN");
        assertEquals("ALICE BALANCE", aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE", bobBalance, ledger.getBalance(BOB), 0);

        assertEquals("ALICE Available BALANCE", aliceBalance - amount, ledger.getAvailableBalance(ALICE), 0);
        assertEquals("BOB Available BALANCE", bobBalance, ledger.getAvailableBalance(BOB), 0);

        PostedTransaction pstd = ledger.performCompleteHold(tran, 100, "done");
        ledger.setReceiptId(pstd.getRequestId(), CryptoTools.createRandomID());

        assertEquals("ALICE BALANCE COMPLETED", aliceBalance - amount, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE COMPLETED", bobBalance + amount, ledger.getBalance(BOB), 0);

        assertEquals("ALICE Available BALANCE COMPLETED", aliceBalance - amount, ledger.getAvailableBalance(ALICE), 0);
        assertEquals("BOB Available BALANCE COMPLETED", bobBalance + amount, ledger.getAvailableBalance(BOB), 0);


        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
        assertTrue("Ledger is balanced", ledger.isBalanced());
    }

    public final void testHoldAndInsufficientFunds() throws LowlevelLedgerException, UnBalancedTransactionException, InvalidTransactionException, UnknownTransactionException, UnknownBookException {
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);
        final double amount = 100;
        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));

        // Now check that it throws InsufficientFundsException
        try {
            hold(ALICE, BOB, new Date(System.currentTimeMillis() + 5000), ledger.getAvailableBalance(ALICE) + 10, "To much");
            assertTrue("InssuficientFundsException should have been thrown", false);
        } catch (InsufficientFundsException e) {
            ;
        }


        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
        assertTrue("Ledger is balanced", ledger.isBalanced());
    }

    public final void testSetReceiptId() throws LedgerException {
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);

        PostedTransaction tran = ledger.transfer(CryptoTools.createRandomID(), ALICE, BOB, 100, "LOAN");

        assertEquals(aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals(aliceBalance, ledger.getAvailableBalance(ALICE), 0);
        assertEquals(bobBalance, ledger.getBalance(BOB), 0);
        assertEquals(bobBalance, ledger.getAvailableBalance(BOB), 0);

        assertNull(tran.getReceiptId());
        try {
            ledger.setReceiptId(tran.getRequestId(), "1234");
        } catch (UnknownTransactionException e) {
            assertTrue(false);
        }
        assertEquals(aliceBalance - 100, ledger.getBalance(ALICE), 0);
        assertEquals(aliceBalance - 100, ledger.getAvailableBalance(ALICE), 0);
        assertEquals(bobBalance + 100, ledger.getBalance(BOB), 0);
        assertEquals(bobBalance + 100, ledger.getAvailableBalance(BOB), 0);


    }

    public final void testTransactionExists() throws LedgerException {
        PostedTransaction tran = transfer("bob", "alice", 100, "does this exist?");
        assertNotNull(tran);
        assertTrue(ledger.transactionExists(tran.getRequestId()));
    }

    public final void testHeldTransactionExists() throws LedgerException {
        ensureBalance(100);
        PostedHeldTransaction tran = hold(ALICE, BOB, new Date(System.currentTimeMillis() + 1000), 100, "does this exist?");
        assertNotNull(tran);
        assertTrue(ledger.heldTransactionExists(tran.getRequestId()));

    }

    public final void testSetHeldReceiptId() throws LedgerException {
        ensureBalance(100);
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);

        PostedHeldTransaction tran = ledger.hold(ALICE, BOB, new Date(System.currentTimeMillis() + 5000), 100, "LOAN");
        assertNull(tran.getReceiptId());
        assertEquals(aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals(aliceBalance, ledger.getAvailableBalance(ALICE), 0);
        assertEquals(bobBalance, ledger.getBalance(BOB), 0);
        assertEquals(bobBalance, ledger.getAvailableBalance(BOB), 0);

        try {
            ledger.setHeldReceiptId(tran.getRequestId(), "1234");
        } catch (UnknownTransactionException e) {
            assertTrue(false);
        }
        PostedHeldTransaction t2 = ledger.findHeldTransaction(tran.getRequestId());
        assertEquals(t2.getRequestId(), "1234", t2.getReceiptId());
        assertEquals(aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals(aliceBalance - 100, ledger.getAvailableBalance(ALICE), 0);
        assertEquals(bobBalance, ledger.getBalance(BOB), 0);
        assertEquals(bobBalance, ledger.getAvailableBalance(BOB), 0);

    }

    public final void testNaiveBenchmark() throws UnBalancedTransactionException, LowlevelLedgerException, InvalidTransactionException, UnknownBookException {
        final int iterations = 100;
        final double amount = 50;
        final String book = "benchbook-" + System.currentTimeMillis();
        final double fundamount = amount * iterations;
        final String fundbook = "fund-" + System.currentTimeMillis();
        final double fundbalance = ledger.getBalance(fundbook);
        transfer(fundbook, book, fundamount, "fund the benchmark");
        System.out.println("Start Balance: " + ledger.getBalance(book));
        assertEquals(fundamount, ledger.getAvailableBalance(book), 0);
        assertEquals(fundamount, ledger.getBalance(book), 0);

        long start = System.currentTimeMillis();
        for (int i = 0; i < iterations; i++) {
            ledger.verifiedTransfer(book, fundbook, amount, "transaction" + i);
        }
        final long duration = System.currentTimeMillis() - start;
        System.out.println("" + iterations + " iterations took " + duration + " ms");
        System.out.println("Each iteration took " + duration / iterations + " ms");
        assertEquals(0, ledger.getAvailableBalance(book), 0);
        assertEquals(0, ledger.getBalance(book), 0);
        assertEquals(fundbalance, ledger.getAvailableBalance(fundbook), 0);
        assertEquals(fundbalance, ledger.getBalance(fundbook), 0);
        assertTrue("Ledger is balanced", ledger.isBalanced());
    }

    public void testRegisterBook() throws LowlevelLedgerException, UnknownBookException {
        String bookid = CryptoTools.createRandomID();
        final Book book1 = ledger.getBook(bookid);
        assertNotNull(book1);
        assertEquals(bookid, book1.getId());
        assertTrue(!book1.getRegistered().after(new Date()));
        assertEquals(book1.getRegistered().getTime(), book1.getUpdated().getTime());
        assertEquals("identity", book1.getType());
        assertEquals(bookid, book1.getNickname());
        assertNull(book1.getSource());
        assertNull(book1.getRegistrationId());

        try {
            Thread.currentThread().sleep(2000);
        } catch (InterruptedException e) {
            ;
        }
        String regid = CryptoTools.createRandomID();
        final Book book2 = ledger.registerBook(bookid, "bob", "asset", "http://hotmail.com", regid);
        assertNotNull(book2);
        assertEquals(bookid, book2.getId());
        assertTrue(!book2.getRegistered().after(new Date()));
//        assertEquals(book1.getRegistered().getTime(),book2.getRegistered().getTime());
        assertTrue(!book2.getUpdated().before(book1.getUpdated()));
        assertTrue(!book2.getUpdated().before(book2.getRegistered()));
        assertEquals("asset", book2.getType());
        assertEquals("bob", book2.getNickname());
        assertNotNull(book2.getSource());
        assertNotNull(book2.getRegistrationId());
        assertEquals(regid, book2.getRegistrationId());

    }

    protected LedgerController ledger;
}
