package org.neuclear.ledger.tests;

import junit.framework.TestCase;
import org.neuclear.ledger.*;

import java.util.Date;

/**
 * (C) 2003 Antilles Software Ventures SA
 * User: pelleb
 * Date: Jan 22, 2003
 * Time: 4:18:35 PM
 * $Id: AbstractLedgerTest.java,v 1.2 2004/03/24 23:12:34 pelle Exp $
 * $Log: AbstractLedgerTest.java,v $
 * Revision 1.2  2004/03/24 23:12:34  pelle
 * Working on Hibernate Implementation.
 *
 * Revision 1.1  2004/03/22 23:20:51  pelle
 * Working on Hibernate Implementation.
 * <p/>
 * Revision 1.2  2004/03/22 21:59:38  pelle
 * SimpleLedger now passes all unit tests
 * <p/>
 * Revision 1.1  2004/03/22 20:08:24  pelle
 * Added simple ledger for unit testing and in memory use
 * <p/>
 * Revision 1.12  2004/03/22 17:33:02  pelle
 * Added a verified transfer to neuclear-ledger.
 * Added InsufficientFundsException to be thrown if transfer isnt verified.
 * HeldTransfers also are now verified.
 * <p/>
 * Revision 1.11  2004/03/21 00:48:36  pelle
 * The problem with Enveloped signatures has now been fixed. It was a problem in the way transforms work. I have bandaided it, but in the future if better support for transforms need to be made, we need to rethink it a bit. Perhaps using the new crypto channel's in neuclear-commons.
 * <p/>
 * Revision 1.10  2004/01/02 23:18:35  pelle
 * Added StatementFactory pattern and refactored the ledger to use it.
 * <p/>
 * Revision 1.9  2003/12/31 00:39:05  pelle
 * Added Drivers for handling different Database dialects in the entity model.
 * Added BookBrowser pattern to ledger, simplifying the statement writing process.
 * <p/>
 * Revision 1.8  2003/12/26 22:50:52  pelle
 * Mainly fixes to SQLLedger to support the schema generated by the new EntityModel
 * <p/>
 * Revision 1.7  2003/12/24 00:24:33  pelle
 * Created a kind of poor man's version of ofbiz.org's EntityEngine. It doesnt use xml to configure it, but code.
 * Should mainly be used to create tables. Can also insert rows, but hasnt been thoroughly tested.
 * At some point I will improve that part and add some kind of smart querying engine to it. Similar to EntityEngine. But I dont
 * need that myself right now.
 * SQLLedger now uses this to create its tables. It is not fully working yet, but will be shortly.
 * <p/>
 * Revision 1.6  2003/12/03 23:21:43  pelle
 * Got rid of ofbiz support. Way over the top for our use.
 * <p/>
 * Revision 1.5  2003/11/21 04:43:21  pelle
 * EncryptedFileStore now works. It uses the PBECipher with DES3 afair.
 * Otherwise You will Finaliate.
 * Anything that can be final has been made final throughout everyting. We've used IDEA's Inspector tool to find all instance of variables that could be final.
 * This should hopefully make everything more stable (and secure).
 * <p/>
 * Revision 1.4  2003/11/11 21:17:32  pelle
 * Further vital reshuffling.
 * org.neudist.crypto.* and org.neudist.utils.* have been moved to respective areas under org.neuclear.commons
 * org.neuclear.signers.* as well as org.neuclear.passphraseagents have been moved under org.neuclear.commons.crypto as well.
 * Did a bit of work on the Canonicalizer and changed a few other minor bits.
 * <p/>
 * Revision 1.3  2003/10/29 21:15:13  pelle
 * Refactored the whole signing process. Now we have an interface called Signer which is the old SignerStore.
 * To use it you pass a byte array and an alias. The sign method then returns the signature.
 * If a Signer needs a passphrase it uses a PassPhraseAgent to present a dialogue box, read it from a command line etc.
 * This new Signer pattern allows us to use secure signing hardware such as N-Cipher in the future for server applications as well
 * as SmartCards for end user applications.
 * <p/>
 * Revision 1.2  2003/10/28 23:43:15  pelle
 * The GuiDialogAgent now works. It simply presents itself as a simple modal dialog box asking for a passphrase.
 * The two Signer implementations both use it for the passphrase.
 * <p/>
 * Revision 1.1.1.1  2003/09/20 23:16:21  pelle
 * First revision of neuclear-ledger in /cvsroot/neuclear
 * Older versions can be found /cvsroot/neuclear
 * <p/>
 * Revision 1.15  2003/08/08 23:05:12  pelle
 * Updated to use PicoContainer.
 * This will be made more elegant as we go along.
 * <p/>
 * Revision 1.14  2003/08/06 19:16:32  pelle
 * Updated various missing items.
 * <p/>
 * Revision 1.13  2003/08/06 16:41:22  pelle
 * Fixed a few implementation bugs with regards to the Held Transactions
 * <p/>
 * Revision 1.12  2003/08/01 21:59:47  pelle
 * More changes to the way helds are managed.
 * <p/>
 * Revision 1.11  2003/07/30 16:27:55  pelle
 * Final fixes for unit tests.
 * Renamed implementHeld() => complete()
 * Had to override reverse() to make complete work.
 * Note: had to "fix" a unit test to make SimpleLedger pass
 * I dont have time to fix it at the moment. I suspect its simple.
 * <p/>
 * Revision 1.10  2003/07/29 22:57:50  pelle
 * New version with refactored support for HeldTransactions.
 * Please note that this causes a sql exception when adding held_item rows.
 * <p/>
 * Revision 1.9  2003/07/28 21:29:15  pelle
 * Changed a few things in the LedgerFactory.
 * Still not quite there yet.
 * <p/>
 * Revision 1.8  2003/07/23 17:19:26  pelle
 * Ledgers now have a required display name.
 * <p/>
 * Revision 1.7  2003/07/21 19:43:39  pelle
 * Moved the Revisioning tests into the main AbstractLedgerTest.
 * Fixed the getTransactionTime method in SQLLedger.
 * <p/>
 * Revision 1.6  2003/07/21 18:35:15  pelle
 * Completed Exception handling refactoring
 * <p/>
 * Revision 1.5  2003/07/21 17:47:37  pelle
 * Held transactions now work in SQL
 * <p/>
 * Revision 1.4  2003/07/18 20:27:39  pelle
 * *** empty log message ***
 * <p/>
 * Revision 1.3  2003/07/17 22:33:57  pelle
 * Fixed various problems. Lets see how we do. I waiting for the autoincrement to work on the entries.
 * <p/>
 * Revision 1.2  2003/07/16 18:08:49  pelle
 * Adding the first parts of sql support.
 * <p/>
 * Revision 1.1  2003/01/25 19:14:47  pelle
 * The ridiculously simple SimpleLedger now passes initial test.
 * I've split the Transaction Class into two sub classes and made Transaction  abstract.
 * The two new Transaction Classes reflect the state of the Transaction and their methods reflect this.
 */
public abstract class AbstractLedgerTest extends TestCase {
    static final String BOB = "bob";
    static final String ALICE = "alice";
    static final String CAROL = "carol";


    public AbstractLedgerTest(final String s) {
        super(s);
    }

    /**
     * Sets up the fixture, for example, open a network connection.
     * This method is called before a test is executed.
     */
    protected void setUp() throws Exception {
        ledger = createLedger();
    }

    /**
     * Tears down the fixture, for example, close a network connection.
     * This method is called after a test is executed.
     */
    protected void tearDown() throws Exception {
        ledger.close();
    }

    public abstract Ledger createLedger() throws LowlevelLedgerException, UnknownLedgerException;

    public final void testTransfer() throws LedgerException {
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);
        final double amount = 100;

        ledger.transfer(ALICE, BOB, amount, "LOAN");
        assertEquals("ALICE BALANCE", aliceBalance - amount, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE", bobBalance + amount, ledger.getBalance(BOB), 0);

        ledger.transfer(BOB, ALICE, amount, "Repayment");
        assertEquals("REPAY ALICE BALANCE", aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals("REPAY BOB BALANCE", bobBalance, ledger.getBalance(BOB), 0);
        ledger.transfer(BOB, ALICE, 5, "Interest");
        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
    }

    public final void testVerifiedTransfer() throws LedgerException {
        // Need a positive amount in alice's account
        if (ledger.getAvailableBalance(ALICE) < 100)
            ledger.transfer("MONEY PRESS", ALICE, -ledger.getAvailableBalance(ALICE) + 100, "FUND");
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);
        final double amount = 100;

        assertTrue("ALICE has a balance of 100 or more", aliceBalance >= 100);

        ledger.verifiedTransfer(ALICE, BOB, amount, "LOAN");
        assertEquals("ALICE BALANCE", aliceBalance - amount, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE", bobBalance + amount, ledger.getBalance(BOB), 0);

        // Now check that it throws InsufficientFundsException
        try {
            ledger.verifiedTransfer(ALICE, BOB, ledger.getAvailableBalance(ALICE) + 10, "To much");
            assertTrue("InssuficientFundsException should have been thrown. Attempted to transfer: " + (ledger.getAvailableBalance(ALICE) + 10), false);
        } catch (InsufficientFundsException e) {
            ;
        }


        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
    }

    public final void testMultiTransfer() throws UnBalancedTransactionException, LowlevelLedgerException, InvalidTransactionException {
        final double bobBalance = ledger.getBalance(CAROL);
        int cumulative = 0;
        for (int i = 0; i < 100; i++) {
            ledger.transfer("req" + i + System.currentTimeMillis(), "x" + i + System.currentTimeMillis(), "Issuer", CAROL, i, "fund it");
            cumulative += i;
            assertEquals("BOB BALANCE", bobBalance + cumulative, ledger.getBalance(CAROL), 0);
            assertEquals("BOB AVAILABLE BALANCE", ledger.getBalance(CAROL), ledger.getAvailableBalance(CAROL), 0);
        }
        System.out.println("Bob's Balance: " + ledger.getBalance(CAROL));
    }

    public final void testBalance() throws LedgerException {
        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
    }

    public final void testHoldAndExpireTransfer() throws LowlevelLedgerException, UnBalancedTransactionException, InvalidTransactionException {
        if (ledger.getAvailableBalance(ALICE) < 100)
            ledger.transfer("MONEY PRESS", ALICE, -ledger.getAvailableBalance(ALICE) + 100, "FUND");
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);
        final double amount = 100;
        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));

        ledger.hold(ALICE, BOB, new Date(System.currentTimeMillis() + 5000), amount, "LOAN");
        assertEquals("ALICE BALANCE", aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE", bobBalance, ledger.getBalance(BOB), 0);

        assertEquals("ALICE Available BALANCE", aliceBalance - amount, ledger.getAvailableBalance(ALICE), 0);
        assertEquals("BOB Available BALANCE", bobBalance, ledger.getAvailableBalance(BOB), 0);
        try {
            Thread.currentThread().sleep(5000);
        } catch (InterruptedException e) {
            ;
        }
        assertEquals("ALICE BALANCE EXPIRED", aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE EXPIRED", bobBalance, ledger.getBalance(BOB), 0);

        assertEquals("ALICE Available BALANCE EXPIRED", aliceBalance, ledger.getAvailableBalance(ALICE), 0);
        assertEquals("BOB Available BALANCE EXPIRED", bobBalance, ledger.getAvailableBalance(BOB), 0);


        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
    }

    public final void testHoldAndCancelTransfer() throws LowlevelLedgerException, UnBalancedTransactionException, InvalidTransactionException, UnknownTransactionException {
        if (ledger.getAvailableBalance(ALICE) < 100)
            ledger.transfer("MONEY PRESS", ALICE, -ledger.getAvailableBalance(ALICE) + 100, "FUND");
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);
        final double amount = 100;
        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));

        PostedHeldTransaction tran = ledger.hold(ALICE, BOB, new Date(System.currentTimeMillis() + 5000), amount, "LOAN");
        assertEquals("ALICE BALANCE", aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE", bobBalance, ledger.getBalance(BOB), 0);

        assertEquals("ALICE Available BALANCE", aliceBalance - amount, ledger.getAvailableBalance(ALICE), 0);
        assertEquals("BOB Available BALANCE", bobBalance, ledger.getAvailableBalance(BOB), 0);

        ledger.performCancelHold(tran);
        assertEquals("ALICE BALANCE CANCELLED", aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE CANCELLED", bobBalance, ledger.getBalance(BOB), 0);

        assertEquals("ALICE Available BALANCE CANCELLED", aliceBalance, ledger.getAvailableBalance(ALICE), 0);
        assertEquals("BOB Available BALANCE CANCELLED", bobBalance, ledger.getAvailableBalance(BOB), 0);


        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
    }

    public final void testHoldAndCompleteTransfer() throws LowlevelLedgerException, UnBalancedTransactionException, InvalidTransactionException, UnknownTransactionException, TransactionExpiredException {
        if (ledger.getAvailableBalance(ALICE) < 100)
            ledger.transfer("MONEY PRESS", ALICE, -ledger.getAvailableBalance(ALICE) + 100, "FUND");
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);
        final double amount = 100;
        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));

        PostedHeldTransaction tran = ledger.hold(ALICE, BOB, new Date(System.currentTimeMillis() + 5000), amount, "LOAN");
        assertEquals("ALICE BALANCE", aliceBalance, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE", bobBalance, ledger.getBalance(BOB), 0);

        assertEquals("ALICE Available BALANCE", aliceBalance - amount, ledger.getAvailableBalance(ALICE), 0);
        assertEquals("BOB Available BALANCE", bobBalance, ledger.getAvailableBalance(BOB), 0);

        ledger.performCompleteHold(tran, 100, "done");
        assertEquals("ALICE BALANCE COMPLETED", aliceBalance - amount, ledger.getBalance(ALICE), 0);
        assertEquals("BOB BALANCE COMPLETED", bobBalance + amount, ledger.getBalance(BOB), 0);

        assertEquals("ALICE Available BALANCE COMPLETED", aliceBalance - amount, ledger.getAvailableBalance(ALICE), 0);
        assertEquals("BOB Available BALANCE COMPLETED", bobBalance + amount, ledger.getAvailableBalance(BOB), 0);


        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
    }

    public final void testHoldAndInsufficientFunds() throws LowlevelLedgerException, UnBalancedTransactionException, InvalidTransactionException, UnknownTransactionException {
        final double aliceBalance = ledger.getBalance(ALICE);
        final double bobBalance = ledger.getBalance(BOB);
        final double amount = 100;
        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));

        // Now check that it throws InsufficientFundsException
        try {
            ledger.hold(ALICE, BOB, new Date(System.currentTimeMillis() + 5000), ledger.getAvailableBalance(ALICE) + 10, "To much");
            assertTrue("InssuficientFundsException should have been thrown", false);
        } catch (InsufficientFundsException e) {
            ;
        }


        System.out.println("Alice's Balance: " + ledger.getBalance(ALICE));
        System.out.println("Bob's Balance: " + ledger.getBalance(BOB));
    }

    public final void testNaiveBenchmark() throws UnBalancedTransactionException, LowlevelLedgerException, InvalidTransactionException {
        final int iterations = 1000;
        final double amount = 50;
        final String book = "benchbook-" + System.currentTimeMillis();
        final double fundamount = amount * (iterations + 1);
        ledger.transfer("fund", book, fundamount, "fund the benchmark");
        System.out.println("Start Balance: " + ledger.getBalance(book));
        assertEquals(fundamount, ledger.getAvailableBalance(book), 0);

        long start = System.currentTimeMillis();
        for (int i = 0; i < iterations; i++) {
            ledger.verifiedTransfer(book, "fund", amount, "transaction" + i);
        }
        final long duration = System.currentTimeMillis() - start;
        System.out.println("" + iterations + " iterations took " + duration + " ms");
        System.out.println("Each iteration took " + duration / iterations + " ms");
        assertEquals(amount, ledger.getAvailableBalance(book), 0);
    }

    protected Ledger ledger;
}
